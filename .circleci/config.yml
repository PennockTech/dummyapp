version: 2

# Assumed environment variables from config:
#   HEROKU_TOKEN:  an auth token for Heroku, needed to configure docker push
#   DOCKERHUB_USER:  Docker Hub user to push to Hub as
#   DOCKERHUB_PASS:  A token or somesuch to authenticate to Docker Hub


defaults: &defaults
  docker:
    - image: domainr/ci:swan
      environment:
        DOCKER_BUILDER_IMAGE: "domainr/ci:swan"
        DOCKER_BUILDER_GOLANG_VERSION: "1.9.4"
        GO_PARENTDIR: "/home/domainr/"
        DOCKERPROJ: "pennocktech/dummyapp"
        BUILD_TAGS: "heroku"
        BUILDER_SYSTEM: "circleci"

# <https://circleci.com/blog/how-to-build-a-docker-image-on-circleci-2-0/>
#  -- the loose gameplan, reworked a fair bit, especially since we have
#     multi-stage to deal with, so the caching would have been wrong for us
#
# <https://circleci.com/docs/2.0/building-docker-images/>
#  -- the default image is currently 17.03.0-ce but multi-stage builds require
#     at least 17.05, so we override; we only _need_ to override for the build
#     stage, but I don't want to debug brokenness when multiple versions of
#     Docker are used at different stages, so we use a consistent image.
#
#     And remember that there's a distinct shortage of Variable Interpolation
#     which we can use.  There are 'references', which are YAML.
#     It seems one way to organize this, used by circle themselves, is to declare
#     a dummy top-level key "references", to hold variables, where the second-level
#     key doesn't matter, but the &name is what's used.  See the common `&defaults`
#     model, which we were already using, but extended a bit more.

references:
  remote_docker_version: &remote_docker_version
    17.11.0-ce

  project_working_dir: &project_working_dir
    ~/go/src/go.pennock.tech/dummyapp

  # We don't need our unusual Docker image pulled for the deploy steps, it will
  # rarely already be on the machine, since the deploy is unlikely to happen on
  # the same host as the build.
  #
  # We pretty much need: a shell, the docker command, whatever the
  # setup_remote_docker tag requires.  Grab a current Docker, since the
  # highest version documented by Circle CI for remote Docker (17.11) is
  # too old to be listed in the Supported tags for docker images.
  # So we'll have 18.02 client talking to 17.11 server within CI, and
  # whatever the external repositories are.
  deployer_image: &deployer_image
    docker:
      - image: docker:18.02.0-ce-git


  # beware these are also embedded in run command-lines:
  build_cache_path: &build_cache_path
    /tmp/cache/docker-layers.tar
  image_persist_path: &image_persist_path
    /tmp/persist/docker-layers.tar
  persist_directory: &persist_directory
    /tmp/persist



jobs:
  build:
    <<: *defaults
    working_directory: *project_working_dir
    steps:
      - checkout
      - setup_remote_docker:
          version: *remote_docker_version

      # FIXME: have a git repo to hold the vendored dependencies, or perhaps
      # do cache these, although note that means restore-cache before checkout
      - run:
          name: Install dependencies
          command: dep ensure -v

      # For languages where there are many slow build steps, or when installing
      # an OS package as part of the final image, a build-cache makes sense.
      # In our case though, we build using an image which has already been
      # pulled from the repository at least once (because we're running in it
      # now, assuming docker.environment.DOCKER_BUILDER_IMAGE == docker.image)
      # and all the content to be built is either in the repo or should be
      # (the dependencies step above still needs a little work).
      # So all that the cache does is serialize to cache something which can
      # as quickly be got from somewhere else.  And the OS image is _huge_, this
      # is not fast.
      #
      # So I'm leaving the cache entries in, commented out with #C#, as an example
      # of how this can be done; but not using it myself.

      #C# - restore_cache:
      #C#     keys:
      #C#       - v1-docker-{{ .Branch }}
      #C#     paths:
      #C#       - *build_cache_path

      #C# - run:
      #C#     name: Build Docker builder image using Docker Layer Cache image-file
      #C#     command: make -w DIND_CACHE_FILE=/tmp/cache/docker-layers.tar MAKE_DOCKER_TARGET=builder caching-build-image

      #C# - save_cache:
      #C#     key: v1-docker-{{ .Branch }}-{{ epoch }}
      #C#     paths:
      #C#       - *build_cache_path

      - run:
          name: Build Docker image
          command: make -w DIND_PERSIST_FILE=/tmp/persist/docker-layers.tar persist-build-image

      - run: make -n step-heroku-deploy > /tmp/persist/heroku-deploy.sh

      - run: make -n push-image > /tmp/persist/docker-hub-deploy.sh

      # Run tests here

      # *** Deploys ***
      #
      # Note that to make the Docker image available to a later workflow step,
      # we need to manually save the exported layer cache for the final
      # image.
      #
      # This is so unclean.
      #
      # But it's more important to not have a deploy failure invalidate the
      # result of the build step, assuming all tests passed.  Deploys should
      # be resumable.
      #
      # And bonus, we can declare an artifact and have the image be pullable
      # via HTTP for manual import!  But we can't retrieve later artifacts
      # without manually glueing Circle CI tokens back in for use within Circle
      # CI, and we've got too much Inception going on already with
      # docker-in-docker, so I don't want to do that.  Thus we stick with
      # "persist" for that.

      - store_artifacts:
          path: *image_persist_path
          destination: docker-image.tar

      - persist_to_workspace:
          root: *persist_directory
          paths: .


  # For the deploy targets, note that unless we checkout again, we don't have
  # the Makefile; we can only persist one root to the workspace, but we don't
  # want to embed in knowledge of where in the Docker image '~' is, since it
  # can vary between builders.
  #
  # While we've built the image with multiple tags, for pushing to Heroku
  # those don't matter, we can just push latest since we also built with that.
  # But for pushing to Docker Hub, the actual tag is precious.
  #
  # Thus we've made sure that the actual deploy steps in GNUmakefile also have
  # standalone modes, with no dependencies; we can use "make -n step-foo" to
  # get the actual deploy instructions emitted, keeping the GNUmakefile as the
  # single source of truth for that.

  deploy_heroku:
    <<: *defaults
    <<: *deployer_image
    steps:
      - setup_remote_docker:
          version: *remote_docker_version
      - run:
          name: Docker Login to Heroku registry
          command: docker login -u _ -p "${HEROKU_TOKEN}" registry.heroku.com
      - attach_workspace:
          at: *persist_directory
      - run:
          name: Load Docker image from persisted workspace
          command: docker load -i /tmp/persist/docker-layers.tar
      - run:
          name: Deploy docker image to Heroku
          command: source /tmp/persist/heroku-deploy.sh

  push_docker_hub:
    <<: *defaults
    <<: *deployer_image
    steps:
      - setup_remote_docker:
          version: *remote_docker_version
      - run:
          name: Docker Login to Docker Hub
          command: docker login -u "${DOCKERHUB_USER}" -p "${DOCKERHUB_PASS}"
      - attach_workspace:
          at: *persist_directory
      - run:
          name: Load Docker image from persisted workspace
          command: docker load -i /tmp/persist/docker-layers.tar
      - run:
          name: Push docker image to Docker Hub
          command: source /tmp/persist/docker-hub-deploy.sh


workflows:
  version: 2

  build_and_deploy:
    jobs:
      - build
      - deploy_heroku:
          context: heroku-and-dockerhub
          requires:
            - build
          filters:
            branches:
              only:
                - master
      - push_docker_hub:
          context: heroku-and-dockerhub
          requires:
            - build
          filters:
            branches:
              ignore:
                - /.*nohub.*/

# vim: sw=2 :
