version: 2.1

# Assumed environment variables from config:
#   HEROKU_API_KEY:  an auth token for Heroku, needed to configure docker push
#   DOCKERHUB_USER:  Docker Hub user to push to Hub as
#   DOCKERHUB_PASS:  A token or somesuch to authenticate to Docker Hub

# Somewhere around when config 2.1 was introduced, Circle CI appear to have
# broken YAML reference based map merging, switching from "last definition
# wins" to "first definition wins", which broke which Docker image was used for
# the Google GCE push.  It also broke the docker hub image but since the
# command was in the build image, that's less noticeable.
#
# So rather than fight something that's under-tested by Circle (although YAML
# spec clearly says later keys win), I've chosen to switch to version 2.1, so
# that this config serves as a continuing "how to set this up for a new
# project" reference, rather than a historical snapshot.  It's probably not as
# good any more, because of other dated assumptions which surely exist.

executors:
  main-builder:
    docker:
      # If changing this from a PT image, then in the environment below, drop
      # EXTRACT_GO_VERSION_FROM_LABEL and instead export
      # DOCKER_BUILDER_GOLANG_VERSION.
      - image: &basic_image pennocktech/ci:purple

    environment:
      DOCKER_BUILDER_IMAGE: *basic_image
      # Rather than hard-code DOCKER_BUILDER_GOLANG_VERSION we can extract
      # it automatically, assuming that the image is ours.
      EXTRACT_GO_VERSION_FROM_LABEL: "com.pennock-tech.versions.go"
      #
      DOCKER_PROJECT: "pennocktech/dummyapp"
      BUILD_TAGS: "heroku zerolog"
      BUILDER_SYSTEM: "circleci"

  # We don't need our unusual Docker image pulled for the deploy steps, it will
  # rarely already be on the machine, since the deploy is unlikely to happen on
  # the same host as the build.
  #
  # We pretty much need: a shell, the docker command, whatever the
  # setup_remote_docker tag requires.  Grab a Docker matching as closely as
  # possible the most recent stable Docker image we can find in the list of
  # supported Docker versions at
  # <https://circleci.com/docs/2.0/building-docker-images/>.
  deploy-to-docker:
    docker:
      - image: docker:18.06.0-ce-git
  deploy-to-gcloud:
    docker:
      # :alpine and :slim are smaller, but omit the docker command
      - image: google/cloud-sdk:latest

references:
  remote_docker_version: &remote_docker_version
    18.06.0-ce

  project_working_dir: &project_working_dir
    ~/dummyapp

  # beware these are also embedded in run command-lines:
  image_persist_path: &image_persist_path
    /tmp/persist/docker-layers.tar
  persist_directory: &persist_directory
    /tmp/persist


jobs:
  build:
    executor: main-builder
    working_directory: *project_working_dir
    steps:
      - checkout
      - setup_remote_docker:
          version: *remote_docker_version

      # FIXME: have a git repo to hold the vendored dependencies, or perhaps
      # do cache these, although note that means restore-cache before checkout.
      # Except that now that we're using Go modules, that restore would be to a
      # different location in the filesystem and so is a much more viable
      # proposition.
      - run:
          name: Install dependencies
          command: go mod download -x

      # For languages where there are many slow build steps, or when installing
      # an OS package as part of the final image, a build-cache makes sense.
      # In our case though, we build using an image which has already been
      # pulled from the repository at least once (because we're running in it
      # now, assuming docker.environment.DOCKER_BUILDER_IMAGE == docker.image)
      # and all the content to be built is either in the repo or should be
      # (the dependencies step above still needs a little work).
      # So all that the cache does is serialize to cache something which can
      # as quickly be got from somewhere else.  And the OS image is _huge_, this
      # is not fast.
      #
      # Note too that caching the built image from a Dockerfile does not
      # cache all the intermediate steps used to create the target, so there's
      # no re-use, so not much point to it.

      # If you had something heavyweight though, then you would use a
      # "restore_cache:", then the "fetch whatever's newer than what I have",
      # then "save_cache" here.  Be sure to version the cache keys, and put the
      # path in the references section above, to catch typos.

      - run:
          name: Build Docker image
          command: ./build/build.with-docker.sh
          environment:
            DIND_PERSIST_FILE: *image_persist_path
            VERBOSE: "2"

      - run:
          name: Create persisted commands for deploy steps
          command: ./build/create-persist-commands.sh
          environment:
            PERSIST_DIR: *persist_directory
            VERBOSE: "2"
            RETAG: "heroku"

      # Run tests here

      # *** Deploys ***
      #
      # Note that to make the Docker image available to a later workflow step,
      # we need to manually save the exported layer cache for the final
      # image.
      #
      # This is so unclean.
      #
      # But it's more important to not have a deploy failure invalidate the
      # result of the build step, assuming all tests passed.  Deploys should
      # be resumable.
      #
      # And bonus, we can declare an artifact and have the image be pullable
      # via HTTP for manual import!  But we can't retrieve later artifacts
      # without manually glueing Circle CI tokens back in for use within Circle
      # CI, and we've got too much Inception going on already with
      # docker-in-docker, so I don't want to do that.  Thus we stick with
      # "persist" for that.

      - store_artifacts:
          path: *image_persist_path
          destination: docker-image.tar

      - persist_to_workspace:
          root: *persist_directory
          paths: .


  # For the deploy targets, note that unless we checkout again, we don't have
  # the Makefile; we can only persist one root to the workspace, but we don't
  # want to embed in knowledge of where in the Docker image '~' is, since it
  # can vary between builders.
  #
  # While we've built the image with multiple tags, for pushing to Heroku
  # those don't matter, we can just push latest since we also built with that.
  # But for pushing to Docker Hub, the actual tag is precious.
  #
  # Thus we've made sure that the actual deploy steps in GNUmakefile also have
  # standalone modes, with no dependencies; we can use "make -n step-foo" to
  # get the actual deploy instructions emitted, keeping the GNUmakefile as the
  # single source of truth for that.

  deploy_heroku:
    executor: deploy-to-docker
    steps:
      - setup_remote_docker:
          version: *remote_docker_version
      - run:
          name: Docker Login to Heroku registry
          command: docker login -u _ -p "${HEROKU_API_KEY}" registry.heroku.com
      - attach_workspace:
          at: *persist_directory
      - run:
          name: Load Docker image from persisted workspace
          command: docker load -i /tmp/persist/docker-layers.tar
      - run:
          name: Deploy docker image to Heroku
          command: /tmp/persist/heroku-deploy.sh

  push_docker_hub:
    executor: deploy-to-docker
    steps:
      - setup_remote_docker:
          version: *remote_docker_version
      - run:
          name: Docker Login to Docker Hub
          command: docker login -u "${DOCKERHUB_USER}" -p "${DOCKERHUB_PASS}"
      - attach_workspace:
          at: *persist_directory
      - run:
          name: Load Docker image from persisted workspace
          command: docker load -i /tmp/persist/docker-layers.tar
      - run:
          name: Push docker image to Docker Hub
          command: /tmp/persist/docker-hub-deploy.sh

  # TODO: setup a project and have this running in GKE, instead of just available from GCR
  push_gce_registry:
    executor: deploy-to-gcloud
    steps:
      - setup_remote_docker:
          version: *remote_docker_version
      - run:
          name: gcloud status report for logs
          command: gcloud info; gcloud auth list
      - attach_workspace:
          at: *persist_directory
      - run:
          name: GCR login
          command: |
            printf '%s\n' "${GCLOUD_AUTH_ENCODED}" | base64 --decode --ignore-garbage > "${HOME}/gcloud-service-key.json"
            gcloud auth activate-service-account --key-file ${HOME}/gcloud-service-key.json
            /tmp/persist/gcloud-login.sh
      - run:
          name: Load Docker image from persisted workspace
          command: docker load -i /tmp/persist/docker-layers.tar
      - run:
          name: Push docker image to GCE
          command: /tmp/persist/gcr-deploy.sh


workflows:
  version: 2

  build_and_deploy:
    jobs:
      - build
#     - deploy_heroku:
#         context: heroku-and-dockerhub
#         requires:
#           - build
#         filters:
#           branches:
#             only:
#               - master
      - push_docker_hub:
          context: heroku-and-dockerhub
          requires:
            - build
          filters:
            branches:
              ignore:
                - /.*nohub.*/
      - push_gce_registry:
          context: google-dummyapp
          requires:
            - build
          filters:
            branches:
              ignore:
                - /.*nogcloud.*/

# vim: sw=2 :
